---
title: "Continuous Integration"
---

import {Framed} from '/snippets/components/framed.jsx';

<Framed 
  background="https://assets.mirurobotics.com/docs/v02/images/developers/background.jpeg"
  image="https://assets.mirurobotics.com/docs/v02/images/config-schemas/header:schema-push.png"
  borderWidth="24px 30px 24px 30px"
  innerRadius="10px"
  outerRadius="14px"
/>

Automating release creation through continuous integration (CI) ensures that your config schemas are always in sync with your codebase. By integrating the Miru CLI into your CI pipeline, you can create releases automatically whenever changes are merged to your main branch.

## Why automate release creation?

Manual release creation is error-prone and time-consuming. By automating this process, you gain:

- **Consistency** — Every release is created the same way, reducing human error
- **Traceability** — Releases are automatically associated with Git commits
- **Speed** — New releases are created immediately after code is merged
- **Validation** — Schema changes are validated before deployment

## Prerequisites

Before setting up CI automation, ensure you have:

1. Config schemas committed to a Git repository
2. Schemas annotated with their [config types](/docs/learn/config-types)
3. A Miru API key with permissions to create releases

### Creating an API key

To authenticate the CLI in your CI environment, you'll need to create an API key:

1. Navigate to **Settings → API Keys** in the [Miru dashboard](https://app.mirurobotics.com/settings/api-keys)
2. Click **Create API Key**
3. Give it a descriptive name (e.g., "GitHub Actions")
4. Copy the key and store it securely — you won't be able to see it again

<Warning>
  Treat your API key like a password. Never commit it to your repository or expose it in logs.
</Warning>

## GitHub Actions

GitHub Actions is the most common CI platform for automating Miru releases. Below is a complete workflow that creates a release whenever changes are pushed to the `main` branch.

### Example workflow

Create a file at `.github/workflows/miru-release.yml`:

```yaml
name: Create Miru Release

on:
  push:
    branches:
      - main
    paths:
      - 'schemas/**'  # Only trigger when schemas change

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Miru CLI
        run: |
          curl -fsSL https://cli.mirurobotics.com/install.sh | bash
          echo "$HOME/.miru/bin" >> $GITHUB_PATH

      - name: Create release
        env:
          MIRU_API_KEY: ${{ secrets.MIRU_API_KEY }}
        run: |
          miru release create \
            --version "1.0.${{ github.run_number }}" \
            --schemas ./schemas
```

### Configuration

| Variable | Description |
|----------|-------------|
| `MIRU_API_KEY` | Your Miru API key, stored as a GitHub secret |
| `--version` | The semantic version for the release |
| `--schemas` | Path to your schema files or directory |

### Setting up secrets

1. Go to your repository's **Settings → Secrets and variables → Actions**
2. Click **New repository secret**
3. Name: `MIRU_API_KEY`
4. Value: Your Miru API key
5. Click **Add secret**

## GitLab CI

For GitLab repositories, add this configuration to your `.gitlab-ci.yml`:

```yaml
stages:
  - release

create-miru-release:
  stage: release
  image: ubuntu:latest
  only:
    - main
    changes:
      - schemas/**
  script:
    - curl -fsSL https://cli.mirurobotics.com/install.sh | bash
    - export PATH="$HOME/.miru/bin:$PATH"
    - miru release create --version "1.0.$CI_PIPELINE_IID" --schemas ./schemas
  variables:
    MIRU_API_KEY: $MIRU_API_KEY
```

Store your API key as a CI/CD variable:

1. Go to **Settings → CI/CD → Variables**
2. Click **Add variable**
3. Key: `MIRU_API_KEY`
4. Value: Your Miru API key
5. Enable **Mask variable** to hide it in logs

## Versioning strategies

The `--version` flag accepts any valid [semantic version](https://semver.org/). Common strategies include:

### Build number versioning

Use the CI build number for automatic incrementing:

```bash
# GitHub Actions
--version "1.0.${{ github.run_number }}"

# GitLab CI
--version "1.0.$CI_PIPELINE_IID"
```

### Git tag versioning

Trigger releases from Git tags for more control:

```yaml
on:
  push:
    tags:
      - 'v*'

# Then use the tag as the version
--version "${{ github.ref_name }}"
```

### Branch-based versioning

Include branch information for pre-release versions:

```bash
--version "1.0.0-${{ github.ref_name }}.${{ github.run_number }}"
```

## Best practices

<AccordionGroup>
  <Accordion title="Trigger only on schema changes">
    Use path filters to avoid unnecessary releases:
    
    ```yaml
    paths:
      - 'schemas/**'
      - 'config/**/*.json'
    ```
  </Accordion>
  
  <Accordion title="Use idempotent versions">
    The CLI handles duplicate schemas gracefully. If you re-run a pipeline with the same schemas, they won't be duplicated in Miru.
  </Accordion>
  
  <Accordion title="Validate schemas locally first">
    Run schema validation in an earlier CI step before creating a release to catch errors early.
  </Accordion>
  
  <Accordion title="Keep API keys secure">
    - Never commit API keys to your repository
    - Use your CI platform's secret management
    - Rotate keys periodically
    - Use the minimum required permissions
  </Accordion>
</AccordionGroup>

## Troubleshooting

### Common errors

<AccordionGroup>
  <Accordion title="Authentication failed">
    Verify that:
    - The `MIRU_API_KEY` environment variable is set
    - The API key is valid and not expired
    - The key has permissions to create releases
  </Accordion>
  
  <Accordion title="Schema not found">
    Ensure the schema path is correct relative to the repository root. The path should point to where the schemas exist after checkout.
  </Accordion>
  
  <Accordion title="Git metadata error">
    The CLI requires a valid Git repository with:
    - A configured remote URL
    - Schemas committed (not just staged)
    - A valid commit history
  </Accordion>
</AccordionGroup>

## Next steps

- Learn more about [creating releases](/docs/learn/releases/create) manually
- Explore the [CLI Reference](/docs/references/cli/release-create) for all available flags
- Set up [custom validation](/docs/learn/releases/custom-validation) for your schemas

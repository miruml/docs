---
title: "Overview"
---

import ConfigSchemaDef from '/snippets/definitions/config-schema.mdx';
import SchemaFormats from '/snippets/schemas/formats.mdx';
import {MutableBadge, ImmutableBadge, EditableBadge} from '/snippets/components/badges.jsx';
import {Framed} from '/snippets/components/framed.jsx';

<Framed background="https://assets.mirurobotics.com/docs/v02/images/config-schemas/background.png" image="https://assets.mirurobotics.com/docs/v02/images/config-schemas/header:panel.png" borderWidth={"32px 56px 0 0"} innerRadius={"0 8px 0 0"} />

<ConfigSchemaDef />

## Properties

<ParamField path="language" type="string">
  <ImmutableBadge />

  The [schema language](/docs/learn/schemas/languages/overview) used to define the schema.

  Allowed values: 
  - `jsonschema`
  - `cue`

</ParamField>

<ParamField path="format" type="enum">
  <ImmutableBadge />

  The file format used to define the schema. 

  <SchemaFormats />

  Allowed values: 
  - `cue`
  - `json`
  - `yaml`

</ParamField>

<ParamField path="content" type="string">
  <ImmutableBadge />

  The raw schema definition, written in the specified schema language.

  The exact contents of a schema file is preserved in Miru, including any comments, whitespace, and formatting.
</ParamField>

<ParamField path="digest" type="string">
  <ImmutableBadge />

  A hash of the canonicalized schema content.

  Digests are computed by converting schemas to a canonical format--a format that ignores whitespace, comments, and other non-semantic differences--and then hashing the result. This is useful for comparing schemas and detecting duplicates.

  Examples: `sha256:45YeoJJ2btBnAKQztAEXEjHsqyyQfC1z1Mw3LLM4xMUy`
</ParamField>

<ParamField path="instance file path" type="string">
  <ImmutableBadge />

  The instance file path is the file path to deploy config instances (for this schema) on a device, relative to the `/srv/miru/config_instances` directory.

  The default instance file path for a schema is `{config-type-slug}.json`, which deploys config instances to `/srv/miru/config_instances/{config-type-slug}.json`.

  Examples: `/v1/mobility.json`, `/config/safety.json`
</ParamField>

<ParamField path="config type" type="Config Type">
  <ImmutableBadge />

  The [config type](/docs/learn/config-types#properties) to which the schema belongs.

  Examples: `Mobility`, `Safety Features`, `Perception`
</ParamField>

## Schema languages

Config schemas are defined using a schema language--a formal language for describing the structure, constraints, and data types of a configuration.

Miru supports:

- [JSON Schema](https://json-schema.org/draft/2020-12) (draft 2020-12)
- [CUE](https://cuelang.org/)

For more information on schema languages, visit the [languages](/docs/learn/schemas/languages/overview) section of this guide.

## File formats

<SchemaFormats />

## Validating instances

The primary purpose of schemas is to validate config instances. Let's look at a simple example to see this in action.

The following is a toy schema written in JSON Schema.

```yaml JSON Schema expandable
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Mobility
type: object
properties:
    max_linear_speed_mps:
        type: number
        minimum: 0.1
        maximum: 5.0
        default: 1.2
    max_angular_speed_radps:
        type: number
        minimum: 0.1
        maximum: 3.0
        default: 1.0
    obstacle_avoidance_enabled:
        type: boolean
        default: true
    navigation_mode:
        type: string
        enum: [conservative, balanced, aggressive]
        default: balanced
    telemetry:
        type: object
        properties:
        upload_interval_sec:
            type: integer
            minimum: 10
            maximum: 300
            default: 60
        heartbeat_interval_sec:
            type: integer
            minimum: 1
            maximum: 60
            default: 10
        required:
        - upload_interval_sec
        - heartbeat_interval_sec
required:
- max_linear_speed_mps
- max_angular_speed_radps
- obstacle_avoidance_enabled
- navigation_mode
- telemetry
```

The schema defines what constitutes a valid config instance in several different ways:

- Names the available properties
- Organizes the configuration structure, placing some properties at the root while nesting other properties into logical groups
- Gives each property a type, such as `number`, `boolean`, etc.
- Constrains the values of each property--minimums, maximums, enumerations, etc.
- Supplies default values to properties where appropriate

Most of these constraints are optional, and many features of JSON Schema are omitted here, but this gives you a flavor of what schemas are capable of.

Say we are deploying the following config instance.

<Frame>
  ![](https://assets.mirurobotics.com/docs/v02/images/devices/editor/invalid-mobility-edit.png)
</Frame>

Unbeknownst to us, the `max_angular_speed_radps` field exceeds the maximum allowed value of 3.0.

Luckily, before deployment to the device, the config instance is validated against the schema, throwing the following error:

<Frame>
  ![](https://assets.mirurobotics.com/docs/v02/images/devices/editor/invalid-mobility-err-msg.png)
</Frame>

Identifying the issue, we correct the `max_angular_speed_radps` field to use the maximum allowed value of 3.0 and deploy the config instance to the device.

<Frame>
  ![](https://assets.mirurobotics.com/docs/v02/images/devices/editor/valid-mobility-edit.png)
</Frame>

This time, the config instance successfully validates against the schema and is deployed to the device.

Although simple in concept, schemas are a powerful tool for preventing typos, misconfigurations, and other preventable errors.

## Empty schemas

While schemas provide significant value in production deployments, defining one from scratch can be a considerable undertaking.

Many teams find it best to begin with an empty schema--one that accepts any configuration--and gradually add constraints. This approach allows you to define the most highly valued constraints first and progressively transition to stricter and stricter schemas as needed.

Below are the empty schemas for JSON Schema and CUE, respectively.

<CodeGroup>

```yaml JSON Schema
$schema: "https://json-schema.org/draft/2020-12/schema"
```


```cue CUE
{}
```

</CodeGroup>
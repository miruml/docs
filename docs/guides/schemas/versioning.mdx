---
title: "Schema versioning"
---

## Overview

Schema versioning in Miru is **flexible and unopinionated**. The version field is a free-form string identifier that supports any versioning strategy your team prefers.

**Key characteristics:**
- No enforced versioning scheme
- Version must be unique per config type
- Supports any strategy: SemVer, CalVer, SchemaVer, simple integers, or custom formats
- Examples: `"v1"`, `"2.0.0"`, `"1"`, `"2024-11-05"`, `"schema-v3"`

**Version uniqueness:**
Each config type can have only one schema with a given version. Attempting to push duplicate versions with different content will result in a conflict error.

## SemVer

**Semantic Versioning** uses a three-part version number: `MAJOR.MINOR.PATCH`

### Format

```
MAJOR.MINOR.PATCH
```

- **MAJOR**: Incompatible API changes (breaking changes)
- **MINOR**: Backward-compatible new functionality
- **PATCH**: Backward-compatible bug fixes

### When to use

SemVer is ideal when:
- Schema evolution parallels software versioning
- You need to communicate breaking vs non-breaking changes
- Your team is already familiar with SemVer from software development

### Example progression

```bash
# Initial release
miru schema push ./schemas/mobility.yaml --version 1.0.0

# Add optional field (backward-compatible)
miru schema push ./schemas/mobility.yaml --version 1.1.0

# Add another optional field
miru schema push ./schemas/mobility.yaml --version 1.2.0

# Remove required field (breaking change)
miru schema push ./schemas/mobility.yaml --version 2.0.0

# Fix constraint bug (backward-compatible fix)
miru schema push ./schemas/mobility.yaml --version 2.0.1
```

### Schema example

```yaml
$miru_config_type_slug: "mobility"
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Mobility Configuration v2.0.1
description: Breaking changes in v2.0.0 - removed legacy field
type: object
properties:
  max_speed_mps:
    type: number
    minimum: 0
    maximum: 5.0
```

<Note>
  Use SemVer when you want to signal compatibility at a glance. Users can immediately understand that upgrading from 1.x to 2.x requires code changes.
</Note>

## CalVer

**Calendar Versioning** uses date-based version identifiers.

### Format options

```
YYYY-MM-DD     # 2024-11-05
YYYY.MM        # 2024.11
YY.MM          # 24.11
YYYY.Q         # 2024.Q4
```

### When to use

CalVer is ideal when:
- Schemas are released on a regular schedule
- Chronological ordering is more important than semantic meaning
- You want to indicate when a schema was released
- Long-term support versions are tied to dates

### Example progression

```bash
# November 2024 release
miru schema push ./schemas/mobility.yaml --version 2024-11-05

# December 2024 release
miru schema push ./schemas/mobility.yaml --version 2024-12-01

# January 2025 release
miru schema push ./schemas/mobility.yaml --version 2025-01-15
```

### Schema example

```yaml
$miru_config_type_slug: "mobility"
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Mobility Configuration 2024-11-05
description: November 2024 quarterly release
```

<Note>
  CalVer is particularly useful for teams with scheduled releases or when you need to track long-term support (LTS) versions based on release dates.
</Note>

## SchemaVer

**Schema Versioning** uses a three-part number specifically designed for data formats: `MODEL-REVISION-ADDITION`

### Format

```
MODEL-REVISION-ADDITION
```

- **MODEL**: Breaking changes (completely incompatible)
- **REVISION**: Breaking changes that can be handled with migration
- **ADDITION**: Non-breaking additions (new optional fields)

### When to use

SchemaVer is ideal when:
- You need to distinguish between different types of breaking changes
- Migration paths are important to communicate
- You're managing data formats rather than software APIs

### Example progression

```bash
# Initial schema
miru schema push ./schemas/mobility.yaml --version 1-0-0

# Add optional field
miru schema push ./schemas/mobility.yaml --version 1-0-1

# Change that requires migration (rename field)
miru schema push ./schemas/mobility.yaml --version 1-1-0

# Add another optional field
miru schema push ./schemas/mobility.yaml --version 1-1-1

# Completely incompatible change
miru schema push ./schemas/mobility.yaml --version 2-0-0
```

### Schema example

```yaml
$miru_config_type_slug: "mobility"
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Mobility Configuration 1-1-0
description: Revision 1-1-0 - Field renamed, migration required
```

<Note>
  SchemaVer excels at communicating migration needs. Version 1-1-0 tells users "this breaks compatibility but can be migrated from 1-0-x".
</Note>

## Simple integer versioning

Simple incrementing integers provide straightforward, easy-to-understand versioning.

### Format

```
1, 2, 3, 4, ...
```

or with prefix:

```
v1, v2, v3, v4, ...
```

### When to use

Simple versioning is ideal when:
- Simplicity is a priority
- Your schema changes are always breaking
- Version semantics aren't critical
- You have a small team with good communication

### Example progression

```bash
# Version 1
miru schema push ./schemas/mobility.yaml --version v1

# Version 2
miru schema push ./schemas/mobility.yaml --version v2

# Version 3
miru schema push ./schemas/mobility.yaml --version v3
```

### Schema example

```yaml
$miru_config_type_slug: "mobility"
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Mobility Configuration v3
description: Version 3 of the mobility schema
```

<Note>
  Simple versioning works well for small teams or when schemas don't change frequently. The lack of semantic information is offset by simplicity.
</Note>

## Custom versioning

Miru's free-form version field supports any custom versioning scheme your organization needs.

### Examples

**Feature-based:**
```bash
miru schema push ./schema.yaml --version mobility-advanced-v1
```

**Release codenames:**
```bash
miru schema push ./schema.yaml --version falcon
miru schema push ./schema.yaml --version hawk
```

**Branch-based:**
```bash
miru schema push ./schema.yaml --version main-20241105
```

**Milestone-based:**
```bash
miru schema push ./schema.yaml --version milestone-3
```

## Version conflict handling

Miru enforces version uniqueness per config type to maintain integrity.

### Scenario 1: Same version, different content

```bash
# First push
miru schema push ./schema-v1.yaml --version v1
# ✅ Success: Created schema v1

# Later: Try to push different content with same version
miru schema push ./schema-v1-updated.yaml --version v1
# ❌ Error: Version conflict - v1 already exists with different content
```

**Resolution:** Use a new version number.

### Scenario 2: Same content, different version

```bash
# First push
miru schema push ./schema.yaml --version v1
# ✅ Success: Created schema v1

# Push identical content as v2
miru schema push ./schema.yaml --version v2
# ❌ Error: Duplicate content detected
```

**Resolution:** Use the `--allow-duplicate` flag:

```bash
miru schema push ./schema.yaml --version v2 --allow-duplicate
# ✅ Success: Created schema v2 (duplicate content allowed)
```

### Scenario 3: Same version, same content (idempotent)

```bash
# First push
miru schema push ./schema.yaml --version v1
# ✅ Success: Created schema v1

# Re-push identical schema
miru schema push ./schema.yaml --version v1
# ✅ Success: No changes (idempotent)
```

## Integration with releases

Schema versions integrate with Miru's release management system.

### Multi-version deployments

A single fleet can run multiple software versions simultaneously, each with different schema versions:

```
Fleet: Production Robots
├── Release v1.0 (50 devices)
│   └── Mobility Schema v1
├── Release v2.0 (30 devices)
│   └── Mobility Schema v2
└── Release v3.0 (20 devices)
    └── Mobility Schema v3
```

### Gradual rollouts

Use versioning to enable gradual schema migrations:

1. **Deploy new software** with updated schema to subset of devices
2. **Monitor** for issues with new schema version
3. **Expand rollout** to more devices if successful
4. **Complete migration** when all devices updated
5. **Deprecate old version** after migration complete

### Version requirements

Software releases can specify which schema versions they're compatible with:

- Release v1.0 → Requires mobility schema v1.x
- Release v2.0 → Requires mobility schema v2.x
- Release v2.1 → Compatible with mobility schema v2.x or v3.x

## Best practices

### Choose the right strategy

Match your versioning strategy to your team's needs:

| Strategy | Best For |
| -------- | -------- |
| **SemVer** | Teams familiar with semantic versioning, when compatibility signaling matters |
| **CalVer** | Scheduled releases, date-based tracking, LTS versions |
| **SchemaVer** | Data formats, when migration paths matter |
| **Simple integers** | Small teams, infrequent changes, simplicity priority |
| **Custom** | Specific organizational needs not covered above |

### Document changes

Always document what changed in each version:

```yaml
$miru_config_type_slug: "mobility"
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Mobility Configuration v2.0.0
description: |
  Version 2.0.0 - Breaking changes
  - BREAKING: Removed deprecated 'max_velocity' field
  - BREAKING: Renamed 'speed_limit' to 'max_speed_mps'
  - Added 'acceleration_limit' field
  - Added 'obstacle_detection' configuration
```

### Version alongside code

Keep schema versions synchronized with your application code:

1. **Store schemas in git** with application code
2. **Tag releases** that include schema changes
3. **Automate schema pushes** in CI/CD pipeline
4. **Version code and schemas together** for traceability

```bash
# In your CI/CD pipeline
git tag v2.0.0
miru schema push ./schemas/mobility.yaml --version 2.0.0
```

### Communicate breaking changes

Make breaking changes obvious:

- **SemVer**: Increment major version (1.x → 2.0)
- **CalVer**: Document in release notes
- **SchemaVer**: Increment model number (1-x-x → 2-0-0)
- **Simple**: Document clearly in schema description

### Plan for deprecation

When introducing breaking changes:

1. **Announce** deprecation in advance
2. **Provide migration guide** for old → new version
3. **Support old version** for transition period
4. **Monitor usage** of old version
5. **Remove old version** only after all devices migrated

## Example: Complete version lifecycle

### Initial release

```bash
# Create initial schema
miru schema push ./mobility-v1.yaml --version 1.0.0
```

```yaml
$miru_config_type_slug: "mobility"
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Mobility v1.0.0
properties:
  max_speed: { type: number }
required: [max_speed]
```

### Non-breaking addition

```bash
# Add optional field
miru schema push ./mobility-v1.1.yaml --version 1.1.0
```

```yaml
properties:
  max_speed: { type: number }
  acceleration: { type: number }  # New optional field
required: [max_speed]
```

### Breaking change

```bash
# Rename field (breaking)
miru schema push ./mobility-v2.yaml --version 2.0.0
```

```yaml
title: Mobility v2.0.0 - Breaking: max_speed renamed to max_speed_mps
properties:
  max_speed_mps: { type: number }  # Renamed field
  acceleration: { type: number }
required: [max_speed_mps]
```

### Bug fix

```bash
# Fix validation bug
miru schema push ./mobility-v2.0.1.yaml --version 2.0.1
```

```yaml
title: Mobility v2.0.1 - Fix: correct acceleration range
properties:
  max_speed_mps: { type: number, minimum: 0, maximum: 5 }
  acceleration: { type: number, minimum: 0, maximum: 2 }  # Fixed range
```

## Next steps

- Explore [creating schemas](/basics/schemas/create)
- Learn about [managing schemas](/basics/schemas/manage)
- Understand [config types](/basics/schemas/config-types)

---
title: "Overview"
---

import ConfigSchemaDef from '/snippets/concepts/config-schema.mdx';

<Frame>
  ![](/images/config-schemas/header:panel.png)
</Frame>

<ConfigSchemaDef />

## Properties

Config schemas leverage several properties to adequately describe their format and organize them within their config type. 

All config schema properties are immutable except for the `instance_filepath` property, which may be updated at anytime.

<ParamField path="language">
The schema language used to define the schema. 

Currently supported schema languages include:
- JSON Schema (Draft 2020-12)
- CUE

Examples: `jsonschema`, `cue`
</ParamField>

<ParamField path="format">
The file format used to define the schema.

Some languages, such as JSON Schema, support multiple formats (e.g. JSON, YAML) while others, such as CUE, only support a single format (i.e. CUE lang itself).

Note that a *schema's* format does not need to be the same as its *config instance's* format. Below is a compatibility matrix for schema and config instance formats.

| Language     | Schema Formats  | Instance Formats |
| ------------ | --------------- | ---------------- |
| JSON Schema  | JSON, YAML      | JSON, YAML       |
| CUE          | CUE             | JSON, YAML       |

Examples: `json`, `yaml`, `cue`
</ParamField>

<ParamField path="content">
The raw schema definition written in the specified schema language.

The exact contents of a schema file is preserved in Miru including any comments, whitespace, and formatting.
</ParamField>

<ParamField path="digest">
A hash of the canonicalized schema content, useful for comparing the contents of two schemas.

Digests are computed by converting a schema to it's canonical form and hashing the result. This is useful for detecting duplicate schemas (even with changes in whitespacing, comments, etc.) and ensuring version integrity.
</ParamField>

<ParamField path="version">
A [semantic version](https://semver.org/), unique for a given config type.

Versions must be dot separated integers. You may optionally use a `v` prefix, a prerelease suffix (e.g. `-beta.1`, `-rc.1`), and/or a build suffix (e.g. `+metadata`).

Examples: `v1`, `1`, `v2.1`, `2.1`, `v3.2.1`, `3.2.1`, `v4.3.2-beta.1`, `4.3.2-rc.1`, `v5.4.3+metadata`, `6.5.4-beta.2+metadata`
</ParamField>

<ParamField path="instance_filepath">
The filepath to deploy config instances (for this schema) on a device relative to the `/srv/miru/config_instances` directory. 

The default instance file path for a schema is `{config-type-slug}.json`, which deploys config instances to `/srv/miru/config_instances/{config-type-slug}.json`.

Individual config instances may override their schema's default file path with a custom file path at deployment time. 

To modify the file path deployed for all future instances of this schema, simply update the `instance_filepath` property.


Examples: `/v1/mobility.json`, `/config/safety.json`
</ParamField>

## Validation

The primary purpose of schemas is to validate config instances. Let's look at a simple example to see how schemas validate config instances.

The following is a toy schema defined using the JSON Schema [language](/docs/guides/schemas/languages).

```yaml JSON Schema [expandable]
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Mobility
type: object
properties:
    max_linear_speed_mps:
        type: number
        minimum: 0.1
        maximum: 5.0
        default: 1.2
    max_angular_speed_radps:
        type: number
        minimum: 0.1
        maximum: 3.0
        default: 1.0
    obstacle_avoidance_enabled:
        type: boolean
        default: true
    navigation_mode:
        type: string
        enum: [conservative, balanced, aggressive]
        default: balanced
    telemetry:
        type: object
        properties:
        upload_interval_sec:
            type: integer
            minimum: 10
            maximum: 300
            default: 60
        heartbeat_interval_sec:
            type: integer
            minimum: 1
            maximum: 60
            default: 10
        required:
        - upload_interval_sec
        - heartbeat_interval_sec
required:
- max_linear_speed_mps
- max_angular_speed_radps
- obstacle_avoidance_enabled
- navigation_mode
- telemetry
```

The schema defines what constitutes a valid config instance in several different ways:

- Names the available properties
- Organizes the configuration structure, placing some properties at the root while nesting other properties in logical groups
- Gives each property a type, such as `number`, `boolean`, etc.
- Constrains the values of each property--minimums, maximums, enumerations, etc.
- Supplies default values to properties where appropriate

Most of these constraints are optional, and many features of JSON Schema are omitted here, but this gives you a flavor of what schemas are capable of.

Say we are deploying the following config instance.

```yaml
  max_linear_speed_mps: 5.6
  max_angular_speed_radps: 1.0
  obstacle_avoidance_enabled: true
  navigation_mode: balanced
  telemetry:
    upload_interval_sec: 60
    heartbeat_interval_sec: 10
```

Unbeknownst to us, the `max_linear_speed_mps` field exceeds the maximum allowed value of 5.0!

Luckily, before deployment begins, the config instance is validated against the schema, throwing the following error:

```
Error: The config instance contains invalid values.
- max_linear_speed_mps: Must be less than or equal to 5.0
```

The config instance is rejected before deployment begins. We then correct the issue and attempt to deploy again:

```yaml
  max_linear_speed_mps: 5.0
  max_angular_speed_radps: 1.0
  obstacle_avoidance_enabled: true
  navigation_mode: balanced
  telemetry:
    upload_interval_sec: 60
    heartbeat_interval_sec: 10
```

This time the config instance successfully validates against the schema and is deployed to the device.

Although simple in concept, schemas are a powerful tool for preventing typos, misconfigurations, and other preventable errors. Schemas are foundational component for a production-ready configuration management system.

## Defaults

A secondary purpose of schemas is to define default values for config instances.

Schemas are a perfect place to define default configuration values. By placing defaults in the schema itself, values are naturally migrated and versioned alongside the schema, preventing drift between default configurations and schema versions.

While some configurations, such as calibrations, do not have sensible default values, defaults should be leveraged for the majority of parameters.

Each schema language has its own way of defining and handling default values--JSON Schema uses the `default` keyword while CUE supports the `| *` syntax.

<CodeGroup>
```yaml JSON Schema
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Defaults
type: object
properties:
    navigation_mode:
        type: string
        enum: [conservative, aggressive]
        default: conservative
required:
- navigation_mode
```

```cue CUE
navigation_mode: "conservative" | "aggressive" | *"conservative"
```
</CodeGroup>

Miru integrates directly with the default values in your schemas. When creating a new config instance, Miru automatically populates the instance with the defaults provided by the schema.

For more information on the expected behavior of default values with Miru, visit the defaults section of a given schema language in the [Schema languages](/docs/guides/schemas/languages) guide.
---
title: "CUE"
---
## Strengths

CUE is strong in several areas: validation, composability, and built-in logic.

### Unified Validation

CUE uses a constraint-based, structural validation model. Instead of separating types from values, CUE treats both as constraints, so you define them in the same place. In CUE, the schema is the set of constraints your data must satisfy.

Here's an example:

```cue
RobotConfig: {
  id:        string & !=""
  armLength: float & >0.1 & <2.0
  payloadKg: int & >= 0 & <= 25
  mode:      "idle" | "active" | "emergency"
  ip:        string & =~ "^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$"
}
```

Each field has an inline constraint to prevent misconfigurations. The `&` operator lets you intersect multiple constraints.

Here's an instance that conforms to the schema:

```cue
myRobot: RobotConfig & {
  id:        "arm-001"
  armLength: 1.2
  payloadKg: 18
  mode:      "active"
  ip:        "192.168.1.42"
}
```

When you run `cue vet`, it checks that all constraints from `RobotConfig` are satisfied by `myRobot`.

If you change `payloadKg` to 100, the validation fails with a clear error:

```
myRobot.payloadKg: conflicting values 100 and int & >=0 & <=25:
    conflicting values 100 and <=25
```

### Official tooling

CUE ships with a powerful CLI that helps you validate, format, and export your configs:

- `cue vet` - Validate data against constraints
- `cue eval` - Merge constraints and output final data
- `cue export` - Emit valid JSON/YAML
- `cue fmt` - Formatter, like gofmt for CUE
- `cue def` - Convert JSON/YAML into a base schema

### Composability & Overrides

CUE excels at composability. It has built composability into its language semantics through logical conjunction (`&`) to merge constraints and values. This means you can define reusable schemas, partial defaults, and environment-specific overrides as independent pieces and merge them when needed.

Here's an example of a base + override:

```cue
BaseConfig: {
  armLength: 1.2
  payloadKg: <= 20
  mode:      "idle"
}

ProductionOverride: {
  mode: "active"
  payloadKg: 18
}

robot01: BaseConfig & ProductionOverride
```

Evaluating `robot01` merges the two objects. All constraints are preserved and checked at merge time:

```json
{
  "armLength": 1.2,
  "payloadKg": 18,
  "mode": "active"
}
```

This construct allows you to build layered configs, either merging various components together or creating overrides on a per-robot basis. This makes CUE uniquely good for managing configs at scale.

### Templating & Logic

CUE supersedes the functionality of a templating engine. It's a declarative language, so you can write rules, expressions, and constraints that safely compute values based on inputs.

CUE supports:

- **Arithmetic & expressions** - `torque / (payload + 1)`
- **Conditional logic** - `status: if emergency then "offline" else "ready"`
- **List comprehensions** - `[for id in robotIDs { id: id, zone: "default" }]`
- **Constraint merging** - `limit: >10, limit: <=25 → limit: >10 & <=25`

<Info>
CUE is **not** Turing-complete. It can't do recursion, unbounded loops, general-purpose function definitions, or import values at runtime. This is by design—it's expressive enough to compute what you need, but bounded enough to stay predictable. Templating engines like Jsonnet and Jinja can be too powerful, introducing infinite loops and runtime failures that deliver bad configs and crash your application.
</Info>

### Self-Documentation & Readability

CUE is reasonably self-documented. It has a strong type system, default values, and field declarations. However, compared to JSON Schema, it lacks richer metadata that are nice to haves with a schema language.

Field types are explicit:

```cue
name: string
payloadKg: int & >= 0 & <= 25
```

You can define enums and constraints inline, which makes intent very clear:

```cue
mode: "idle" | "active" | "emergency"
```

You can annotate with comments, and they persist through evaluation and formatting:

```cue
// Max load the robot can carry in kg
payloadKg: int & >= 0 & <= 25
```

You can also use `cue def` or `cue export` to generate a "flattened" version of the config—useful for introspection or documentation tooling.

<Info>
CUE borrows heavily from Go's syntax and semantics. For engineers not familiar with Go, there can be some ramp-up needed.
</Info>

## Weaknesses

While CUE is strong in many areas, it has a few weaknesses worth noting.

### Code Generation

CUE is tightly integrated with Go, but struggles with other languages. If you're not using Go (which most robotics stacks aren't), your best bet is to go from CUE → JSON Schema → code generation.

For static languages like Rust, this works well. For dynamic languages, you'll need CI checks to make sure your code and schema don't drift.

Unlike JSON Schema which has mature, language-specific code generation tools (like quicktype, datamodel-code-generator, schemars), CUE has no first-class code generation outside of Go.

The multi-step workflow (CUE → JSON Schema → target language) works but requires:
- Multiple tools in your build pipeline
- Careful attention to which constraints translate correctly
- CI checks to prevent drift between schema and code

For teams that need type-safe code generation in multiple languages, this can be a significant operational burden compared to using JSON Schema directly.

### Limited Language Support

CUE is tightly integrated with Go but struggles with other languages. This is the biggest limitation for robotics teams, as most robotics stacks use a mix of Python, C++, and Rust rather than Go.

If you're not using Go, you must go through the CUE → JSON Schema → code generation workflow described above. This adds complexity and can result in lossy translation where some CUE constraints don't map cleanly to JSON Schema.

While the ecosystem is growing quickly, limited language support will remain a challenge in the short to medium term. Teams using CUE alongside other languages will need to maintain the translation pipeline and ensure schemas don't drift from generated code.


## Summary

CUE is a schema language purpose-built for configuration. It combines validation, logic, and composition into a single language, making it especially useful for teams managing complex, dynamic configs.

CUE's strengths come from its logic and computation. You can write conditionals, compute derived values, and merge overrides natively. In terms of logic and expressiveness, CUE offers more out of the box than any other schema language.

The main downside is limited language support outside of Go. Teams using CUE alongside Python, C++, or Rust will need to translate CUE into JSON Schema to unlock code generation.

If you're looking for a config language that has logic, inheritance, and validation all in one place, CUE is an option worth exploring.

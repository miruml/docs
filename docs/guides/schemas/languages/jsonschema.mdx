---
title: "JSON Schema"
---



## Strengths

JSON Schema is strong in several areas: wide adopton, simple syntax, and code generation tooling.

### Community

JSON Schema is maintained by the [JSON Schema organization](https://github.com/json-schema-org) and backed by an army of open-source tools and libraries. While JSON Schema organization itself doesn't maintain any tools, the open-source community around it is largely unparallelled.

Some of the most popular open-source projects rely on JSON Schema including OpenAPI, Docker Compose, AsyncAPI, and Kubernetes. Furthermore, many of the foremost software companies build with JSON Schema including Microsoft, AWS, OpenAI, GitHub, and more.

### Familiar syntax

JSON Schema's syntax is very intuitive and easy to learn for most developers. If you've used OpenAPI before, you'll find the JSON Schema'ssyntax similar if not identical.

If you haven't worked with OpenAPI but are familiar with JSON or YAML, you should find JSON Schema to quite easy to pick up. Below is an example JSON Schema written in YAML.

### Validation

JSON Schema was initially built for validation and provides a wide range of keywords for doing so. Some highlights are listed below.

- **Type enforcement** - supports the common data types such as strings, numbers, booleans, null values, objects, arrays, etc.
- **Constraint rules** - add a wide range of limits and conditions such as required fields, string length, number ranges, enum values, and much more
- **Reusability** - keywords such as `$ref` allow the reuse of schema components
- **Composition** - keywords such as `allOf`, `anyOf`, `oneOf`, `if/then/else` allow for the composition of schemas in complex ways

While Miru handles the schema validation for you, it's useful to know that open-source JSON Schema validation libraries exist in nearly every programming language. Several of the most popular are given below.

| Language | Library |
| -------- | ------- |
| JavaScript | [ajv](https://ajv.js.org/) |
| Python | [jsonschema](https://github.com/python-jsonschema/jsonschema) |
| Go | [tekuri-jsonschema](https://github.com/santhosh-tekuri/jsonschema) |
| Rust | [json-schema-rs](https://github.com/Stranger6667/jsonschema) |
| C++ | [json-schema-validator](https://github.com/pboettch/json-schema-validator) |


### Code generation

The most popular library for code generation is [quicktype](https://quicktype.io/), which supports most popular programming languages including JavaScript, Python, Go, Rust, C++, and many more.

Of course, other language-specific tools are popular as well. Here are few:

- [datamodel-code-generator](https://github.com/koxudaxi/datamodel-code-generator) - Python via Pydantic
- [schemars](https://github.com/ThomsonReutersEikon/schemars) - Rust via Serde

## Weaknesses

While JSON Schema is strong in many areas, it has a few weaknesses that are worth noting.

### Verbosity

JSON Schema is *extremely* verbose, particularly for large, complex schemas. 

While this is a minor weakness, the number of fields used to describe a schema is enourmous, making it especially difficult to read and navigate large JSON Schemas. 

JSON Schema's verbosity is especially apparent when compared to a schema language like CUE, which inlines most constraints into a single line. Below are roughly equivalent schemas written in JSON Schema and CUE. As you can see, JSON Schema is about three times as long as CUE in this example.

<CodeGroup>

```yaml JSON Schema [expandable]
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Communication Configuration Schema
type: object
required:
  - control_loop_rate_hz
  - watchdog_timeout_ms
  - network
  - logging
  - error_handling
properties:
  control_loop_rate_hz:
    type: integer
    description: Control loop frequency in Hertz
    minimum: 1
    maximum: 1000  
    default: 50
  watchdog_timeout_ms:
    type: integer
    description: Watchdog timeout duration in milliseconds
    minimum: 100   
    maximum: 5000  
    default: 500
  network:
    type: object
    required:
      - max_latency_ms
      - connection_timeout_ms
      - reconnect_attempts
      - reconnect_interval_ms
      - heartbeat_interval_ms
    properties:
      max_latency_ms:
        type: integer
        description: Maximum acceptable network latency in milliseconds
        minimum: 10    
        maximum: 1000  
        default: 100
      connection_timeout_ms:
        type: integer
        description: Connection timeout duration in milliseconds
        minimum: 100    
        maximum: 10000  
        default: 2000
      reconnect_attempts:
        type: integer
        description: Number of reconnection attempts
        minimum: 1
        maximum: 10    
        default: 3
      reconnect_interval_ms:
        type: integer
        description: Interval between reconnection attempts in milliseconds
        minimum: 100    
        maximum: 5000   
        default: 1000
      heartbeat_interval_ms:
        type: integer
        description: Interval between heartbeat messages in milliseconds
        minimum: 50     
        maximum: 1000   
        default: 250
  logging:
    type: object
    required:
      - enable_packet_logging
      - log_level
      - max_log_size_mb
      - retain_logs_days
    properties:
      enable_packet_logging:
        type: boolean
        description: Enable or disable packet logging
        default: true
      log_level:
        type: string
        description: Logging level
        enum: ["debug", "info", "warn", "error"]
        default: "info"
      max_log_size_mb:
        type: integer
        description: Maximum log file size in megabytes
        minimum: 1
        maximum: 1024  
        default: 100
      retain_logs_days:
        type: integer
        description: Number of days to retain log files
        minimum: 1
        maximum: 90    
        default: 30
  error_handling:
    type: object
    required:
      - max_consecutive_failures
      - failure_timeout_ms
      - enable_auto_recovery
    properties:
      max_consecutive_failures:
        type: integer
        description: Maximum number of consecutive failures allowed
        minimum: 1
        maximum: 20    
        default: 5
      failure_timeout_ms:
        type: integer
        description: Timeout duration for failure handling in milliseconds
        minimum: 100    
        maximum: 30000  
        default: 5000
      enable_auto_recovery:
        type: boolean
        description: Enable or disable automatic recovery from failures
        default: true
```

```cue CUE [expandable]
control_loop_rate_hz: number & >=1 & <=1000 | *50
// Watchdog timeout duration in milliseconds
watchdog_timeout_ms: number & >=100 & <=5000 | *500

network: {
	// Maximum acceptable network latency in milliseconds
	max_latency_ms: number & >=10 & <=1000 | *100
	// Connection timeout duration in milliseconds
	connection_timeout_ms: number & >=100 & <=10000 | *2000
	// Number of reconnection attempts
	reconnect_attempts: number & >=1 & <=10 | *3
	// Interval between reconnection attempts in milliseconds
	reconnect_interval_ms: number & >=100 & <=5000 | *1000
	// Interval between heartbeat messages in milliseconds
	heartbeat_interval_ms: number & >=50 & <=1000 | *250
}

logging: {
	// Enable or disable packet logging
	enable_packet_logging: bool | *true
	// Logging level
	log_level: "debug" | "info" | "warn" | "error" | *"info"
	// Maximum log file size in megabytes
	max_log_size_mb: number & >=1 & <=1024 | *100
	// Number of days to retain log files
	retain_logs_days: number & >=1 & <=90 | *30
}

error_handling: {
	// Maximum number of consecutive failures allowed
	max_consecutive_failures: number & >=1 & <=20 | *5
	// Timeout duration for failure handling in milliseconds
	failure_timeout_ms: number & >=100 & <=30000 | *5000
	// Enable or disable automatic recovery from failures
	enable_auto_recovery: bool | *true
}
```
</CodeGroup>

### Templating & Logic

JSON Schema was designed for validating JSON instances, not rendering them. As such, templating capabilities such as conditionals, loops, functions, overrides, etc. are not supported by JSON Schema. 

Luckily, Miru is purpose-built for config management and will soon provide purpose-built capabilities for rendering config instances, leaving this weakness of JSON Schema largely irrelevant.

However, it's worth noting that to render configs on you own, you must use a separate tool such as Jinja or Jsonnet.

---
title: "JSON Schema"
---

<Frame>
  ![](/images/schema-langs/jsonschema/website.png)
</Frame>

With origins dating back to 2010, [JSON Schema](https://json-schema.org/) is one of the most widely adopted schema languages today. Originally built for API validation, it has since found its way into configuration systems across web, cloud, and robotics infrastructure.

## Example

Below is an example JSON Schema to give you a flavor of what JSON Schema looks like.

```yaml JSON Schema [expandable]
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Communication Configuration Schema
type: object
required:
  - control_loop_rate_hz
  - watchdog_timeout_ms
  - network
  - logging
  - error_handling
properties:
  control_loop_rate_hz:
    type: integer
    description: Control loop frequency in Hertz
    minimum: 1
    maximum: 1000  
    default: 50
  watchdog_timeout_ms:
    type: integer
    description: Watchdog timeout duration in milliseconds
    minimum: 100   
    maximum: 5000  
    default: 500
  network:
    type: object
    required:
      - max_latency_ms
      - connection_timeout_ms
      - reconnect_attempts
      - reconnect_interval_ms
      - heartbeat_interval_ms
    properties:
      max_latency_ms:
        type: integer
        description: Maximum acceptable network latency in milliseconds
        minimum: 10    
        maximum: 1000  
        default: 100
      connection_timeout_ms:
        type: integer
        description: Connection timeout duration in milliseconds
        minimum: 100    
        maximum: 10000  
        default: 2000
      reconnect_attempts:
        type: integer
        description: Number of reconnection attempts
        minimum: 1
        maximum: 10    
        default: 3
      reconnect_interval_ms:
        type: integer
        description: Interval between reconnection attempts in milliseconds
        minimum: 100    
        maximum: 5000   
        default: 1000
      heartbeat_interval_ms:
        type: integer
        description: Interval between heartbeat messages in milliseconds
        minimum: 50     
        maximum: 1000   
        default: 250
  logging:
    type: object
    required:
      - enable_packet_logging
      - log_level
      - max_log_size_mb
      - retain_logs_days
    properties:
      enable_packet_logging:
        type: boolean
        description: Enable or disable packet logging
        default: true
      log_level:
        type: string
        description: Logging level
        enum: ["debug", "info", "warn", "error"]
        default: "info"
      max_log_size_mb:
        type: integer
        description: Maximum log file size in megabytes
        minimum: 1
        maximum: 1024  
        default: 100
      retain_logs_days:
        type: integer
        description: Number of days to retain log files
        minimum: 1
        maximum: 90    
        default: 30
  error_handling:
    type: object
    required:
      - max_consecutive_failures
      - failure_timeout_ms
      - enable_auto_recovery
    properties:
      max_consecutive_failures:
        type: integer
        description: Maximum number of consecutive failures allowed
        minimum: 1
        maximum: 20    
        default: 5
      failure_timeout_ms:
        type: integer
        description: Timeout duration for failure handling in milliseconds
        minimum: 100    
        maximum: 30000  
        default: 5000
      enable_auto_recovery:
        type: boolean
        description: Enable or disable automatic recovery from failures
        default: true
```

Although many of JSON Schema's capabilities are omitted in this example, you'll find some of the most common keywords including:

- `$schema` - specifies the JSON Schema draft version
- `type` - the data type of a property
- `required` - signals that a property is required
- `properties` - the sub-fields of an object
- `default` - the default value of a property
- `description` - the description of a property
- `enum` - a constrained list of allowed values for a property (only for string types)
- `minimum` - the minimum value of a property (only for numeric types)
- `maximum` - the maximum value of a property (only for numeric types)

For a comprehensive list of JSON Schema keywords, visit the [official JSON Schema website](https://json-schema.org/understanding-json-schema/keywords). We also find the [official test suite](https://github.com/json-schema-org/JSON-Schema-Test-Suite/tree/main/tests/draft2020-12) highly useful for perusing a vast number of simple JSON Schema examples that showcase its capabilities.


## Supported Drafts

While JSON Schema has a variety of drafts, Miru only supports JSON Schema [Draft 2020-12](https://json-schema.org/draft/2020-12), the most recent stable draft.

When specifying the `$schema` keyword in a schema (which is recommended), it must be set to the following value:

```yaml
$schema: "https://json-schema.org/draft/2020-12/schema"
```

<Info>
  If the `$schema` keyword is omitted from a schema, the schema is automatically interpreted as Draft 2020-12.
</Info>

## Supported Keywords

Miru supports the full suite of JSON Schema keywords for Draft 2020-12.

Miru also conducts a few additional checks to keep schemas well-maintained.

## File formats

While JSON Schema was originally built for JSON, it is not exclusive to JSON. As you may have noticed, we're partial to writing JSON Schema in YAML for readability (no excessive brackets and we can use comments!).

**Schema Formats**

Miru supports JSON Schemas written in the following formats:
- **JSON** (`.json`)
- **YAML** (`.yaml`, `.yml`)

**Instance Formats**

Miru supports the validation of JSON Schema instances in the following formats:
- **JSON** (`.json`)
- **YAML** (`.yaml`, `.yml`)

A schema's format does not need to match the format of the instance it validates. A YAML schema can validate JSON instances and vice versa.

## Validating defaults

JSON Schema considers default values [annotations](https://json-schema.org/understanding-json-schema/reference/annotations)--supplementary information that is not part of the schema itself. As a result, JSON Schema allows the definition of properties which contain invalid default values.

For example, the following schema defines the property `foo` with a default value of `"bar"`, which is an invalid value for a number type. 

```yaml
$schema: "https://json-schema.org/draft/2020-12/schema"
type: object
properties:
  foo:
    type: number
    default: "bar"
```

Although discouraged, JSON Schema does allow such definitions since defaults are purely an annotation.

Since Miru populates default values into config instances, it's vital that the default values are valid according to the schema. Thus, Miru rejects valid JSON Schemas if their default values are inconsistent with the schema itself.

## Strengths

JSON Schema is strong in several areas: wide adopton, simple syntax, and code generation tooling.

### Community

JSON Schema is maintained by the [JSON Schema organization](https://github.com/json-schema-org) and backed by an army of open-source tools and libraries. While JSON Schema organization itself doesn't maintain any tools, the open-source community around it is largely unparallelled.

Some of the most popular open-source projects rely on JSON Schema including OpenAPI, Docker Compose, AsyncAPI, and Kubernetes. Furthermore, many of the foremost software companies build with JSON Schema including Microsoft, AWS, OpenAI, GitHub, and more.

### Familiar syntax

JSON Schema's syntax is very intuitive and easy to learn for most developers. If you've used OpenAPI before, you'll find the JSON Schema'ssyntax similar if not identical.

If you haven't worked with OpenAPI but are familiar with JSON or YAML, you should find JSON Schema to quite easy to pick up. Below is an example JSON Schema written in YAML.

### Validation

JSON Schema was initially built for validation and provides a wide range of keywords for doing so. Some highlights are listed below.

- **Type enforcement** - supports the common data types such as strings, numbers, booleans, null values, objects, arrays, etc.
- **Constraint rules** - add a wide range of limits and conditions such as required fields, string length, number ranges, enum values, and much more
- **Reusability** - keywords such as `$ref` allow the reuse of schema components
- **Composition** - keywords such as `allOf`, `anyOf`, `oneOf`, `if/then/else` allow for the composition of schemas in complex ways

While Miru handles the schema validation for you, it's useful to know that open-source JSON Schema validation libraries exist in nearly every programming language. Several of the most popular are given below.

| Language | Library |
| -------- | ------- |
| JavaScript | [ajv](https://ajv.js.org/) |
| Python | [jsonschema](https://github.com/python-jsonschema/jsonschema) |
| Go | [tekuri-jsonschema](https://github.com/santhosh-tekuri/jsonschema) |
| Rust | [json-schema-rs](https://github.com/Stranger6667/jsonschema) |
| C++ | [json-schema-validator](https://github.com/pboettch/json-schema-validator) |


### Code generation

The most popular library for code generation is [quicktype](https://quicktype.io/), which supports most popular programming languages including JavaScript, Python, Go, Rust, C++, and many more.

Of course, other language-specific tools are popular as well. Here are few:

- [datamodel-code-generator](https://github.com/koxudaxi/datamodel-code-generator) - Python via Pydantic
- [schemars](https://github.com/ThomsonReutersEikon/schemars) - Rust via Serde

## Weaknesses

While JSON Schema is strong in many areas, it has a few weaknesses that are worth noting.

### Verbosity

JSON Schema is *extremely* verbose, particularly for large, complex schemas. 

While this is a minor weakness, the number of fields used to describe a schema is enourmous, making it especially difficult to read and navigate large JSON Schemas. 

JSON Schema's verbosity is especially apparent when compared to a schema language like CUE, which inlines most constraints into a single line. Below are roughly equivalent schemas written in JSON Schema and CUE. As you can see, JSON Schema is about three times as long as CUE in this example.

<CodeGroup>

```yaml JSON Schema [expandable]
$schema: "https://json-schema.org/draft/2020-12/schema"
title: Communication Configuration Schema
type: object
required:
  - control_loop_rate_hz
  - watchdog_timeout_ms
  - network
  - logging
  - error_handling
properties:
  control_loop_rate_hz:
    type: integer
    description: Control loop frequency in Hertz
    minimum: 1
    maximum: 1000  
    default: 50
  watchdog_timeout_ms:
    type: integer
    description: Watchdog timeout duration in milliseconds
    minimum: 100   
    maximum: 5000  
    default: 500
  network:
    type: object
    required:
      - max_latency_ms
      - connection_timeout_ms
      - reconnect_attempts
      - reconnect_interval_ms
      - heartbeat_interval_ms
    properties:
      max_latency_ms:
        type: integer
        description: Maximum acceptable network latency in milliseconds
        minimum: 10    
        maximum: 1000  
        default: 100
      connection_timeout_ms:
        type: integer
        description: Connection timeout duration in milliseconds
        minimum: 100    
        maximum: 10000  
        default: 2000
      reconnect_attempts:
        type: integer
        description: Number of reconnection attempts
        minimum: 1
        maximum: 10    
        default: 3
      reconnect_interval_ms:
        type: integer
        description: Interval between reconnection attempts in milliseconds
        minimum: 100    
        maximum: 5000   
        default: 1000
      heartbeat_interval_ms:
        type: integer
        description: Interval between heartbeat messages in milliseconds
        minimum: 50     
        maximum: 1000   
        default: 250
  logging:
    type: object
    required:
      - enable_packet_logging
      - log_level
      - max_log_size_mb
      - retain_logs_days
    properties:
      enable_packet_logging:
        type: boolean
        description: Enable or disable packet logging
        default: true
      log_level:
        type: string
        description: Logging level
        enum: ["debug", "info", "warn", "error"]
        default: "info"
      max_log_size_mb:
        type: integer
        description: Maximum log file size in megabytes
        minimum: 1
        maximum: 1024  
        default: 100
      retain_logs_days:
        type: integer
        description: Number of days to retain log files
        minimum: 1
        maximum: 90    
        default: 30
  error_handling:
    type: object
    required:
      - max_consecutive_failures
      - failure_timeout_ms
      - enable_auto_recovery
    properties:
      max_consecutive_failures:
        type: integer
        description: Maximum number of consecutive failures allowed
        minimum: 1
        maximum: 20    
        default: 5
      failure_timeout_ms:
        type: integer
        description: Timeout duration for failure handling in milliseconds
        minimum: 100    
        maximum: 30000  
        default: 5000
      enable_auto_recovery:
        type: boolean
        description: Enable or disable automatic recovery from failures
        default: true
```

```cue CUE [expandable]
// Control loop frequency in Hertz
control_loop_rate_hz: number & >=1 & <=1000 | *50
// Watchdog timeout duration in milliseconds
watchdog_timeout_ms: number & >=100 & <=5000 | *500

network: {
	// Maximum acceptable network latency in milliseconds
	max_latency_ms: number & >=10 & <=1000 | *100
	// Connection timeout duration in milliseconds
	connection_timeout_ms: number & >=100 & <=10000 | *2000
	// Number of reconnection attempts
	reconnect_attempts: number & >=1 & <=10 | *3
	// Interval between reconnection attempts in milliseconds
	reconnect_interval_ms: number & >=100 & <=5000 | *1000
	// Interval between heartbeat messages in milliseconds
	heartbeat_interval_ms: number & >=50 & <=1000 | *250
}

logging: {
	// Enable or disable packet logging
	enable_packet_logging: bool | *true
	// Logging level
	log_level: "debug" | "info" | "warn" | "error" | *"info"
	// Maximum log file size in megabytes
	max_log_size_mb: number & >=1 & <=1024 | *100
	// Number of days to retain log files
	retain_logs_days: number & >=1 & <=90 | *30
}

error_handling: {
	// Maximum number of consecutive failures allowed
	max_consecutive_failures: number & >=1 & <=20 | *5
	// Timeout duration for failure handling in milliseconds
	failure_timeout_ms: number & >=100 & <=30000 | *5000
	// Enable or disable automatic recovery from failures
	enable_auto_recovery: bool | *true
}
```
</CodeGroup>

### Templating & Logic

JSON Schema was designed for validating JSON instances, not rendering them. As such, templating capabilities such as conditionals, loops, functions, overrides, etc. are not supported by JSON Schema. 

Luckily, Miru is purpose-built for config management and will soon provide purpose-built capabilities for rendering config instances, leaving this weakness of JSON Schema largely irrelevant.

However, it's worth noting that to render configs on you own, you must use a separate tool such as Jinja or Jsonnet.

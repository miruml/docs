The second part of a policy is its overrides. An **override** references tag metadata that _overrides_ the current evaluation of a policy. Here is a `hardware` override example.

<img height="200" src="/images/vocabulary/hardware-override.png" style={{borderRadius: '7px'}}/>

The default values in the policy schema are shown on the left. On the right is the hardware override, which references the `supports_jump`, `supports_spin`, and `supports_backflip` fields in the metadata schema for the `hardware` tag type. 

Overrides are wholly defined by you. An override only needs to specify a subset of the policy schema fields. However, it cannot specify fields which are not present in the policy schema.

Policies can only be evaluated given a particular tag. For instance, the `features.jump`, `features.spin`, and `features.backflip` fields in the hardware override reference the `supports_jump`, `supports_spin`, and `supports_backflip` fields in the metadata schema for the `hardware` tag type.

Given the `NVIDIA Jetson Orin Nano` tag, the hardware override would use `features.jump: true`, `features.spin: true`, and `features.backflip: false` since the `NVIDIA Jetson Orin Nano` tag has `supports_jump: true`, `supports_spin: true`, and `supports_backflip: false`. This would override the default values in the policy schema, changing `features.spin` from `false` to `true`.

Overrides are hierarchically evaluated to determine a concrete config for a client. The client's tags determine the specific values referenced by overrides.

<img height="200" src="/images/vocabulary/policy-override.png" style={{borderRadius: '7px'}}/>

By combining tags with overrides, policies grant a flexible method to evaluate configuration data unique to each client that's formatted according to a given config schema
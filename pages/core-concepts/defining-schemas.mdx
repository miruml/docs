---
title: 'Defining Schemas'
---

import ConcreteConfigDefinition from '/snippets/concrete-config-definition.mdx';
import ConfigDefinition from '/snippets/config-definition.mdx';
import ConfigSchemaDefinition from '/snippets/config-schema-definition.mdx';

To begin we need to cover some terminology surrounding configurations.

## Terminology

<ConcreteConfigDefinition />

<ConfigSchemaDefinition />

<ConfigDefinition />

With these definitions out of the way, let's begin.

## Defining Config Schemas

Miru requires you to define a config schema to deploy a concrete config. These schemas are used to validate concrete configs before they are deployed, effectively preventing runtime application errors. These schemas **live in your git repository** (preferably in the same repository as the code consuming the config) to minimize versioning errors between code and configurations.

Let's say your application uses a "motion control" config to configure the motion of your robot. Your application might have the following directory structure.

```
src/...
configs/
â”œâ”€â”€ motion-control-config.yaml
â””â”€â”€ ...
config-schemas/
â”œâ”€â”€ motion-control-schema.yaml
â””â”€â”€ ...
```

The `motion-control-config.yaml` file defines concrete config values for **development use only**. As a developer you should be able to define and edit your configurations in your local development environment quickly and easily. The `motion-control-config.yaml` file serves this purpose exactly. The file will not be uploaded to the cloud nor will it be used in any way to deploy concrete configs to your devices in production. It is strictly for local development purposes.

The `motion-control-schema.yaml` file defines the schema for the concrete `motion-control-config.yaml` config, specifying the constraints on the parameters it can instantiate.

<Accordion title="motion-control-config.yaml">
```yaml
speed: 10
features:
  spin: true
  jump: true
  backflip: false
accelerometer:
  id: acc_id_1
  offsets:
    x: 0.1
    y: 0.13
    z: -0.04
  scaling_factor:
    x: 1.0
    y: 1.02
    z: 0.99
```
</Accordion>

<Accordion title="motion-control-schema.yaml">
```yaml 
$schema: "https://json-schema.org/draft/2020-12/schema"
type: object
properties:
  speed:
    type: integer
    minimum: 1
    default: 10
  features:
    type: object
    properties:
      spin:
        type: boolean
        default: true
      jump:
        type: boolean
        default: false
      backflip:
        type: boolean
        default: false
    required: [spin, jump, backflip]
  accelerometer:
    type: object
    properties:
      id:
        type: string
      offsets:
        type: object
        properties:
          x:
            type: number
          y:
            type: number
          z:
            type: number
        required: [x, y, z]
      scaling_factor:
        type: object
        properties:
          x:
            type: number
          y:
            type: number
          z:
            type: number
        required: [x, y, z]
    required: [id, offsets, scaling_factor]
required: [device_id, speed, features, accelerometer]
```
</Accordion>

## Local Development 
Miru provides an [SDK](/pages/guides/sdk) for deploying concrete configs to your devices in production. 

<CodeGroup>
```python Python
[INSERT CODE]
```

```rust Rust
[INSERT CODE]
```

```cpp C++
[INSERT CODE]
```
</CodeGroup>

It's critical that an SDK allows you to easily iterate through concrete config values in your local development environment while providing a production-ready interface for deployment. The SDK accepts a boolean argument to determine whether it should use the concrete config values defined on the local file system (development) or fetch them from the cloud (production).

<CodeGroup>
```python Python
[INSERT CODE]
```

```rust Rust
[INSERT CODE]
```

```cpp C++
[INSERT CODE]
```
</CodeGroup>

This allows you to quickly change concrete config values in your local development environment while reading in the concrete config values from the cloud in production.

You are not required to use the config values of the Miru SDK directly when in production. Instead you can have the SDK update a file on the filesystem with the desired config. 

<CodeGroup>
```python Python
[INSERT CODE]
```

```rust Rust
[INSERT CODE]
```

```cpp C++
[INSERT CODE]
```
</CodeGroup>

Then you can then read the concrete config from the file system as normal, whether in development or production.

## Uploading the Config Schema

You've finished a sprint and are ready to deploy your code and configurations to your fleet. The first step is uploading your config schemas to the cloud. Miru provides a [CLI](/pages/guides/cli) to accomplish this.

```bash
miru upload \
--config-slug="motion-control-config" \
--config-schema-path="./configs/motion-control-schema.yaml"
```

The `miru upload` command will take some git information to help you version control and track your config schemas when viewing them in the Miru dashboard. It's important to note that Miru **does not have access to your git repository**. The git information is simply extracted from the git repository where the `miru upload` command is run from.

```bash
$ miru upload --config-slug="motion-control-config" --config-schema-path="./configs/motion-control-schema.yaml"

ðŸš€ Attempting to upload schema ./configs/motion-control-schema.yaml for config motion-control-config...

Git Information:
commit: 8f4d2e1
origin: git@github.com:miru/config-service.git
branch: origin/main

âœ… Successfully uploaded schema for config motion-control-config
Schema is now available for use in production deployments.
```

After running `miru upload`, you'll be able to see your config schema in the Miru dashboard along with the git information and the version number.

<img src="/images/product-outline/motion-control-schema-list.png" style={{borderRadius: '7px'}}/>

We recommend using the `miru upload` command in your CI pipeline to automatically upload your config schemas to Miru. Miru will know if a config schema has changed and will not create new a config schema if it has already been uploaded in a previous commit.
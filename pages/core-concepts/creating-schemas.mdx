---
title: 'Creating Schemas'
---

import ConcreteConfigDefinition from '/snippets/concrete-config-definition.mdx';
import ConfigDefinition from '/snippets/config-definition.mdx';
import ConfigSchemaDefinition from '/snippets/config-schema-definition.mdx';

To begin, we need to define Miru's vocabulary surrounding configurations.

## Vocabulary

### Concrete Configs
<ConcreteConfigDefinition />

### Config Schemas
<ConfigSchemaDefinition />

### Configs
<ConfigDefinition />

With these definitions out of the way, let's begin.

## Creating Config Schemas

Miru requires you to define a config schema to deploy a config. These schemas validate concrete configs before deployment, effectively preventing runtime application errors. Config schemas **live in your git repository** (preferably in the same repository as the code consuming the config) to minimize versioning errors between code and configurations.

Let's say your application uses a "motion control" config to configure the motion of your robot. Your application might have the following directory structure.

```
src/...
configs/
â”œâ”€â”€ motion-control-config.yaml
â””â”€â”€ ...
config-schemas/
â”œâ”€â”€ motion-control-schema.yaml
â””â”€â”€ ...
```

The `motion-control-config.yaml` file defines concrete config values for **development use only**. As a developer, you should be able to define and edit configurations in your local development environment quickly and easily. The `motion-control-config.yaml` file serves this purpose exactly. The file will not be uploaded to the cloud or used to deploy concrete configs to your production devices. It is strictly for local development purposes.

The `motion-control-schema.yaml` file defines the schema for the concrete `motion-control-config.yaml` config, specifying the constraints on the parameters it can instantiate.

<Accordion title="motion-control-config.yaml">
```yaml
speed: 10
features:
  spin: true
  jump: true
  backflip: false
accelerometer:
  id: acc_id_1
  offsets:
    x: 0.1
    y: 0.13
    z: -0.04
  scaling_factor:
    x: 1.0
    y: 1.02
    z: 0.99
```
</Accordion>

<Accordion title="motion-control-schema.yaml">
```yaml 
$schema: "https://json-schema.org/draft/2020-12/schema"
type: object
properties:
  speed:
    type: integer
    minimum: 1
    default: 10
  features:
    type: object
    properties:
      spin:
        type: boolean
        default: true
      jump:
        type: boolean
        default: false
      backflip:
        type: boolean
        default: false
    required: [spin, jump, backflip]
  accelerometer:
    type: object
    properties:
      id:
        type: string
      offsets:
        type: object
        properties:
          x:
            type: number
          y:
            type: number
          z:
            type: number
        required: [x, y, z]
      scaling_factor:
        type: object
        properties:
          x:
            type: number
          y:
            type: number
          z:
            type: number
        required: [x, y, z]
    required: [id, offsets, scaling_factor]
required: [device_id, speed, features, accelerometer]
```
</Accordion>

## Local Development 
Miru provides an [SDK](/pages/guides/sdk) for deploying configs. We'll cover this more in-depth later, but the key point to know here is that the SDK pulls concrete configs from the cloud.

<CodeGroup>
```python Python
motion_control_config = client.get_config(
    slug="motion-control-config",
    schema_file="./config-schemas/motion-control-schema.yaml",
)
```

```rust Rust
let motion_control_config = client.get_config(
    "motion-control-config",
    "./config-schemas/motion-control-schema.yaml"
);
```

```cpp C++
auto motion_control_config = client->getConfig(
    "motion-control-config",
    "./config-schemas/motion-control-schema.yaml"
);
```
</CodeGroup>

However, it's critical that an SDK allows you to easily change concrete config values in your local development environment as well. The SDK accepts a boolean argument to determine whether it should fetch a concrete config from a file on the local file system (development) or from the cloud (production).

<CodeGroup>
```python Python
motion_control_config = client.get_config(
    # ... other parameters that don't matter for development
    development_file="./configs/motion-control-config.yaml",
    development=true,
)
```

```rust Rust
let motion_control_config = client.get_config(
    // ... other parameters that don't matter for development
    "./configs/motion-control-config.yaml",
    true,
);
```

```cpp C++
auto motion_control_config = client->getConfig(
    // ... other parameters that don't matter for development
    "./configs/motion-control-config.yaml",
    true,
);
```
</CodeGroup>

This allows you to quickly iterate through values in development without ever leaving your IDE while providing the same SDK interface for fetching config values from the cloud when deploying in production.

It's important to note that, although not recommended, you are not required to use the config values returned by the Miru SDK in production either. Instead, you can tell the SDK to update a file on your file system with the desired config. 

<CodeGroup>
```python Python
client.write_config(
    slug="motion-control-config",
    schema_file="./path/to/config/schema.yaml",
    dest_file="./path/to/place/config.yaml",
)
```

```rust Rust
client.write_config(
    "motion-control-config",
    "./config-schemas/motion-control-schema.yaml",
    "./configs/motion-control-config.yaml",
)
```

```cpp C++
client->writeConfig(
    "motion-control-config",
    "./path/to/config/schema.yaml",
    "./path/to/place/config.yaml",
);
```
</CodeGroup>

If using this method, you can update a file with a concrete config and then read the concrete config from the file system in your code as normal.

## Uploading a Config Schema

You've finished a sprint and are ready to deploy your code and configurations to your fleet. The first step is uploading your config schemas to the cloud. Miru provides a [CLI](/pages/guides/cli) to accomplish this.

```bash
miru upload \
--config-slug="motion-control-config" \
--config-schema-path="./configs/motion-control-schema.yaml"
```

The `miru upload` command collects some git information to help you version control and track your config schemas when viewing them in the Miru dashboard. It's important to note that Miru **does not have access to your git repository**. The git information is extracted from the git repository where the `miru upload` command is run from.

```bash
$ miru upload --config-slug="motion-control-config" --config-schema-path="./configs/motion-control-schema.yaml"

ðŸš€ Attempting to upload schema ./configs/motion-control-schema.yaml for config motion-control-config...

Git Information:
commit: 8f4d2e1
origin: git@github.com:miru/config-service.git
branch: origin/main

âœ… Successfully uploaded schema for config motion-control-config
Schema is now available for use in production deployments.
```

After running `miru upload`, you'll be able to see your config schema in the Miru dashboard alongside the git information and the version number.

<img src="/images/core-concepts/motion-control-schema-list.png" style={{borderRadius: '7px'}}/>

We recommend using the `miru upload` command in your CI pipeline to upload your config schemas automatically. Miru will know if a config schema has changed and will not create a new config schema if it has already been uploaded in a previous commit.